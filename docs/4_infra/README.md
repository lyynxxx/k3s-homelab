## Core infra - MetalLB, Traefik, cert-manager

In the kingdom of Kubernetes, the cluster may be the castle — but without its core infrastructure, it's just an empty husk with no guards at the gate. That’s where our trio of essential guardians enter the tale: MetalLB, the silent courier of IPs, grants your services an identity in the physical realm; Traefik, the graceful gatekeeper, routes external travelers through your labyrinth of services; and Cert-Manager, the arcane scribe of trust, conjures and renews TLS certificates so your domains may speak in encrypted tongues. Together, they form the foundation upon which your apps may live, scale, and safely greet the outside world.

Like a spell nestled within a greater invocation, the core infrastructure of this cluster is conjured through layered rituals — each one precise, each one critical. This is no cheerful automation; it is a grim orchestration of power, carved in YAML and watched by a silent daemon that never sleeps. In this Git-bound grimdark world, the repository becomes a spellbook, and structure is survival. There is no single doctrine — many valid layouts exist across the lands. Some choose to bind multiple clusters to a single repository, weaving their configs together with care and chaos. But here, we follow a colder path: one cluster per repository, a clean division to avoid bleed-through of secrets and intent.

Within this structure, the heart of the system beats in the "k3s-homelab/infra/controller" directory — where the great beasts are summoned: MetalLB, Traefik, and Cert-Manager. They are deployed first, raw and powerful. Then, once stable, the sub-spells are cast from "k3s-homelab/infra/config" — the IP pools, the middlewares, the issuers and certificates — each one a precise binding, each one reliant on its master being present. This separation isn’t just neatness — it’s control. The difference between structured GitOps and configuration carnage. Between a system that heals itself... and one that falls apart the moment your attention fades.

All summoned sources — Helm charts, Git repositories, and artifact bindings — are bound within the "k3s-homelab/helmreleases" directory, a single nexus where the lifeblood of the cluster flows. In a world already haunted by too many paths and too much YAML, this brings clarity: one place to look when the magic breaks, one place to maintain when the stars align.

## [MetalLB (https://metallb.io/)](https://metallb.io/)

In this enchanted realm, MetalLB (which is a load-balancer implementation for bare metal Kubernetes clusters, using standard routing protocols) has been summoned not as a chaotic bringer of random IPs, but as a precise and disciplined steward of two sacred addresses. The first IP is the main gate — the single, resolute entry point through which all external traffic flows. Bound by DNS A records and guarded by Traefik, it routes brave requests through the maze of services behind it, acting as both herald and sentinel. The second IP, however, is cloaked in shadow; it serves only the Traefik dashboard, and is reachable only from the inner sanctum — my internal network and the VPN-bound realms I trust. This dashboard’s gates are sealed by an IP filter middleware, a warding spell that rejects all but the chosen few, ensuring that no rogue agent or wandering bot may peer into the cluster’s inner thoughts. It’s a clean separation of concerns, a balance of visibility and secrecy — and like any good defensive enchantment, it relies on simplicity, vigilance, and the occasional firewall chant.

The "k3s-homelab/infra/controller/metallb" folder holds the three sacred scrolls required to awaken and maintain this particular daemon — and each serves its purpose in the summoning sequence. The first, namespace.yaml, is the humble foundation — it carves out a dedicated corner of the cluster, an isolated sanctum where MetalLB may reside without interference. Next comes the real invocation: helmrelease.yaml, which references to the central MetalLb archives defined in the "k3s-homelab/helmreleases" directory and installs a specific version of MetalLB. This spell doesn’t just install — it controls, defining its sync interval as every ten minutes, and giving it five minutes to succeed or perish in flames. Finally, kustomization.yaml is the beacon that declares, “These are the files to watch.” It is referenced later from the main "k3s-homelab/cluster" directory, telling Flux: “This is where the magic lives. Observe. Reconcile. Obey.” Together, these three form a tidy but powerful ritual — modular, observable, and loyal to Git above all else.

Deep within the "k3s-homelab/cluster" folder, where FluxCD keeps its watchful eye over the state of all things, lies the "metallb-infra.yaml" file — a binding scroll of high authority. This is not a how-to, but a what-shall-be. It tells Flux, “Observe the "k3s-homelab/infra/controller/metallb" path. Inside lie the instructions for summoning the namespace, the HelmRelease, the expectations.” While the controller folder contains the recipes, versions, and incantations, this file is the royal decree — declaring to Flux that MetalLB must exist, must be managed, and must conform to the will of the Git repository. It is the difference between a dusty grimoire and a spell actively cast.

Once MetalLB is summoned and its presence solidified, the time comes to shape its will — to bind it with parameters and purpose. This is where "k3s-homelab/cluster/metallb-infra-config.yaml" steps forth, a second binding scroll, that tells Flux to watch over "k3s-homelab/infra/config/metallb", where the true configuration manifests dwell: the IP pools, the L2Advertisement spells, the declarations of what IPs may be handed out and how they are whispered to the network. But this scroll is cautious, wise — it bears a dependsOn clause, pointing to metallb-infra.yaml, ensuring that MetalLB’s body must exist before its soul is spoken into place. Without that dependency, the configuration might arrive too early, cast into a void where no daemon listens. With it, we ensure a proper order of magic — a system that builds itself not with haste, but with intention.

Maybe, do you see a pattern?

 - Create the install instructions (step by step, like create the namespace, create the helmrelease with custom values)
 - Then bind it to Flux to keep an eye on this
 - Create some fine tuning and configuration
 - Bind it to Flux to keep an eye on this just like before, with the controller, but keep it dependent on the helm install
 - Now, that one part of the infrastructure is ready, add a new part, which is dependent... like Traefik

And **never** ever use the same values for interval and timeout!  

## Traefik

With MetalLB awakened and bound to the network, the next guardian must rise—Traefik, the ingress controller, the gatekeeper of all traffic flowing into the realm. Like MetalLB, its summoning begins with a triad of scrolls: namespace.yaml to mark its territory, helmrelease.yaml to call forth a specific incarnation with precise values, and kustomization.yaml to tie the threads together under Flux’s gaze. All in the "k3s-homelab/infra/controller/traefik" folder. But this is no default spawn — we shape it as a DaemonSet, anchoring Traefik to every node like a vigilant sentry, ensuring we have roads everywhere. The externalTrafficPolicy is set to Local, ensuring incoming traffic lands exactly where it enters, preserving source IPs like footprints in enchanted stone.

And though the dashboard is awakened through an exposed port—tcp/9000 — we do not immediately open the gates to it. No, this interface is powerful, and like any dangerous relic, it must be protected. For now, it lies dormant, unreachable by the masses (each node stands guard with its own local firewall, a last bastion of defense, ensuring that even though the port is technically open, it cannot be reached from the outside world. Only internal routing paths — those forged in trusted subnets — may whisper to this port). Later, once the infrastructure is fully armed, shall we wrap it in a custom IngressRoute, sealed behind an IP whitelist middleware, known only to trusted networks and VPN shadows. Thus, Traefik rises — publicly poised, privately fortified, and bound by Git to remain ever-watchful and ever-consistent.

With Traefik now standing sentinel at the edge of the cluster, it is time to unlock its hidden chamber — the dashboard, a map of all traffic and routes flowing through the gates (in the "k3s-homelab/infra/config/traefik" folder). But such power is not handed out freely. In the depths of "k3s-homelab/infra/config/traefik/traefik-dashboard-mw.yaml", we craft a middleware — a protective ward in the form of an ipAllowList. Its rules are simple and absolute: only those who approach from within the sacred realm of 192.168.0.0/16 shall be allowed to pass. All others, no matter how clever or persistent, shall find only silence.

This middleware is later bound to the ingress gateway through "traefik-dashboard-ingressroute.yaml", which acts as the formal entrance to the dashboard. There, the middlewares array calls upon our "dashboard-ipwhitelist", forming a chained incantation that wraps our traffic in both logic and law. The ingress route itself is tied to a custom "service—traefik-dashboard-service.yaml" — our declaration of what the dashboard is and how it may be reached. Yet none of this magic may be cast until Traefik itself exists, which is enforced through the binding defined in "cluster/traefik-infra-config.yaml". There, Flux reads the runes and understands: only after the gatekeeper stands may we bestow it with its secret mirror. And so, the dashboard lives — shielded, segmented, and watched, a window for the trusted few.

